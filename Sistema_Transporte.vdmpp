-- CLASE: SistemaTransporte
-- Descripción: Fachada del sistema, punto de entrada principal
-- Responsabilidad: Coordinar todas las operaciones del sistema
-- Patrón: Facade

class SistemaTransporte

instance variables
  public buses: map seq of char to Bus := {|->};
  public rutas: map seq of char to Ruta := {|->};
  public conductores: map seq of char to Conductor := {|->};
  public infracciones: seq of Infraccion := [];
  public nombreSistema: seq of char := "Sistema de Control de Transporte Publico - Arequipa";
  public version: seq of char := "1.0";

operations
  public SistemaTransporte: () ==> SistemaTransporte
  SistemaTransporte() == (
    buses := {|->};
    rutas := {|->};
    conductores := {|->};
    infracciones := [];
    nombreSistema := "Sistema de Control de Transporte Publico - Arequipa";
    version := "1.0";
    return self;
  )
  post buses = {|->} and rutas = {|->} and conductores = {|->} and 
       infracciones = [] and 
       nombreSistema = "Sistema de Control de Transporte Publico - Arequipa" and
       version = "1.0";

  -- OPERACIONES DE REGISTRO

  public registrarRuta: Ruta ==> ()
  registrarRuta(ruta) == (
    rutas := rutas munion {ruta.codigo |-> ruta};
  )
  pre ruta.codigo not in set dom rutas
  post ruta.codigo in set dom rutas;

  public registrarBus: Bus ==> ()
  registrarBus(bus) == (
    buses := buses munion {bus.placa |-> bus};
  )
  pre bus.placa not in set dom buses and 
      bus.rutaAsignada.codigo in set dom rutas
  post bus.placa in set dom buses;

  public registrarConductor: Conductor ==> ()
  registrarConductor(conductor) == (
    conductores := conductores munion {conductor.dni |-> conductor};
  )
  pre conductor.dni not in set dom conductores
  post conductor.dni in set dom conductores;

  -- OPERACIONES CRÍTICAS

  public registrarParada: seq of char * Coordenada * nat ==> bool
  registrarParada(placa, ubicacion, timestamp) == (
    dcl bus: Bus := buses(placa);
    dcl esOficial: bool := false;
    dcl paraderos: seq of Paradero := bus.rutaAsignada.obtenerParaderos();
    dcl infraccion: Infraccion;

    for i = 1 to len paraderos do (
      if paraderos(i).estaEnRadio(ubicacion) and paraderos(i).esOficial then
        esOficial := true;
    );

    if not esOficial then (
      infraccion := new Infraccion(
        placa, ubicacion, timestamp,
        "Parada fuera de paradero oficial", "GRAVE"
      );
      infracciones := infracciones ^ [infraccion];
    );
    return esOficial;
  )
  pre placa in set dom buses
  post len infracciones >= len infracciones~ or RESULT = true;

  public consultarETA: seq of char * seq of char ==> real
  consultarETA(placa, codigoParadero) == (
    dcl bus: Bus := buses(placa);
    dcl ruta: Ruta := bus.rutaAsignada;
    dcl paraderoDestino: [Paradero] := nil;
    dcl paraderos: seq of Paradero := ruta.obtenerParaderos();
    
    for i = 1 to len paraderos do (
      if paraderos(i).codigo = codigoParadero then
        paraderoDestino := paraderos(i);
    );
    
    return bus.estimarTiempoArribo(
      paraderoDestino, 
      ruta.factorCongestion, 
      ruta.velocidadPromedio
    );
  )
  pre placa in set dom buses
  post RESULT >= 0;

  -- CONSULTAS DE INFRACCIONES

  public consultarInfraccionesPorBus: seq of char ==> seq of Infraccion
  consultarInfraccionesPorBus(placa) == (
    dcl resultado: seq of Infraccion := [];
    for i = 1 to len infracciones do (
      if infracciones(i).idBus = placa then
        resultado := resultado ^ [infracciones(i)];
    );
    return resultado;
  )
  post forall i in set elems RESULT & i.idBus = placa;

  public consultarInfraccionesPorEmpresa: seq of char ==> seq of Infraccion
  consultarInfraccionesPorEmpresa(nombreEmpresa) == (
    dcl resultado: seq of Infraccion := [];
    for i = 1 to len infracciones do (
      if infracciones(i).idBus in set dom buses and 
         buses(infracciones(i).idBus).empresa = nombreEmpresa then
        resultado := resultado ^ [infracciones(i)];
    );
    return resultado;
  );

  public consultarInfraccionesPorPeriodo: nat * nat ==> seq of Infraccion
  consultarInfraccionesPorPeriodo(inicio, fin) == (
    dcl resultado: seq of Infraccion := [];
    for i = 1 to len infracciones do (
      if infracciones(i).fechaHora >= inicio and infracciones(i).fechaHora <= fin then
        resultado := resultado ^ [infracciones(i)];
    );
    return resultado;
  )
  pre inicio <= fin
  post forall i in set elems RESULT & 
    i.fechaHora >= inicio and i.fechaHora <= fin;

  public contarInfraccionesPendientes: () ==> nat
  contarInfraccionesPendientes() == (
    dcl count: nat := 0;
    for i = 1 to len infracciones do (
      if not infracciones(i).procesada then
        count := count + 1;
    );
    return count;
  )
  post RESULT >= 0 and RESULT <= len infracciones;

  public obtenerBusConMasInfracciones: () ==> seq of char
  obtenerBusConMasInfracciones() == (
    dcl maxPlaca: seq of char := "";
    dcl maxCount: nat := 0;
    dcl count: nat;
    
    for all placa in set dom buses do (
      count := len consultarInfraccionesPorBus(placa);
      if count > maxCount then (
        maxCount := count;
        maxPlaca := placa;
      );
    );
    return maxPlaca;
  )
  pre len infracciones > 0;

  -- CONSULTAS OPERATIVAS

  public obtenerEstadisticas: () ==> nat * nat * nat * nat
  obtenerEstadisticas() == (
    dcl totalBuses: nat := card dom buses;
    dcl busesActivos: nat := 0;
    dcl totalInfracciones: nat := len infracciones;
    dcl infraccionesPendientes: nat := contarInfraccionesPendientes();
    
    for all placa in set dom buses do (
      if buses(placa).enServicio then
        busesActivos := busesActivos + 1;
    );
    
    return mk_(totalBuses, busesActivos, totalInfracciones, infraccionesPendientes);
  );

  public obtenerRutasActivas: () ==> seq of Ruta
  obtenerRutasActivas() == (
    dcl resultado: seq of Ruta := [];
    
    for all codigo in set dom rutas do (
      if rutas(codigo).activa then
        resultado := resultado ^ [rutas(codigo)];
    );
    return resultado;
  )
  post forall r in set elems RESULT & r.activa;

  public obtenerBusesEnRuta: seq of char ==> seq of Bus
  obtenerBusesEnRuta(codigoRuta) == (
    dcl resultado: seq of Bus := [];
    
    for all placa in set dom buses do (
      if buses(placa).rutaAsignada.codigo = codigoRuta then
        resultado := resultado ^ [buses(placa)];
    );
    return resultado;
  )
  pre codigoRuta in set dom rutas
  post forall b in set elems RESULT & b.rutaAsignada.codigo = codigoRuta;

  public validarConductorParaBus: seq of char * Bus * nat ==> bool
  validarConductorParaBus(dni, bus, timestamp) == (
    dcl conductor: Conductor;
    dcl categoria: seq of char;
    
    if dni not in set dom conductores then
      return false;
    
    conductor := conductores(dni);
    
    if not conductor.licenciaVigente(timestamp) then
      return false;
    
    categoria := conductor.categoria;
    if bus.capacidad <= 27 then
      return categoria = "A-IIb"
    elseif bus.capacidad <= 40 then
      return categoria in set {"A-IIb", "A-IIIa"}
    elseif bus.capacidad <= 90 then
      return categoria in set {"A-IIb", "A-IIIa", "A-IIIb"}
    else
      return categoria = "A-IIIc";
  );

end SistemaTransporte